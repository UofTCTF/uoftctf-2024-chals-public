# Basic Overflow

Hello there!

As you might have noticed, the pwn challenges
this year are more basic. This is because we want to focus on
teaching the basics of pwn, and not just throwing you into the
deep end. Next year, good luck pwning, because they will be
much harder.

This challenge is a classic stack-based buffer overflow, and you
should be able to solve it with just a little bit of knowledge
about how the stack works.

First, we don't have the source code, so we need to reverse
engineer the binary. There are many ways to do this, but
objdump is a good tool to start with.
I like to use the intel syntax, but you can use whatever you want.

```bash
$ objdump -M intel -d basic-overflow
```


This will give you the assembly code for the binary.
Let's examine the main function:

```
0000000000401156 <main>:
  401156:       55                      push   rbp
  401157:       48 89 e5                mov    rbp,rsp
  40115a:       48 83 ec 40             sub    rsp,0x40
  40115e:       48 8d 45 c0             lea    rax,[rbp-0x40]
  401162:       48 89 c7                mov    rdi,rax
  401165:       b8 00 00 00 00          mov    eax,0x0
  40116a:       e8 d1 fe ff ff          call   401040 <gets@plt>
  40116f:       b8 00 00 00 00          mov    eax,0x0
  401174:       c9                      leave
  401175:       c3                      ret
```

One of the first things you want to examine when reading a function
is the prologue and epilogue. The prologue is the code that runs
at the beginning of the function, and the epilogue is the code
that runs at the end of the function. The prologue usually sets
up the stack frame, and the epilogue usually tears it down.

In this example, the prologue is:

```
	401156:       55                      push   rbp
	401157:       48 89 e5                mov    rbp,rsp
	40115a:       48 83 ec 40             sub    rsp,0x40
```

This code pushes the base pointer onto the stack, saving it
for later. Then, it moves the stack pointer into the base pointer,
so that the base pointer points to the end (higher memory address) of the stack frame.
Finally, it subtracts 0x40 from the stack pointer, allocating
0x40 bytes of space on the stack.

This means that the stack frame is 0x40 bytes long.

```
[ 0x40 bytes of stack frame ][ 0x8 bytes old rbp ][ return address ]
```

The epilogue is:

```
	401174:       c9                      leave
	401175:       c3                      ret
```

This code tears down the stack frame. First, the leave instruction it moves the base pointer into the stack pointer, so now the stack
frame is gone, then it pops the saved base pointer off the stack.
Finally, the ret instruction pops the return address off the stack
and jumps to it.

```
  40116f:       b8 00 00 00 00          mov    eax,0x0
```

The above instruction is the return statement. It moves 0 into eax,
and then the epilogue pops the return address off the stack and
jumps to it. Nothing special here. It's just the same as 
`return 0;` in C.

Now here is the vulnerable part.

```
	40115e:       48 8d 45 c0             lea    rax,[rbp-0x40]
	401162:       48 89 c7                mov    rdi,rax
	401165:       b8 00 00 00 00          mov    eax,0x0
	40116a:       e8 d1 fe ff ff          call   401040 <gets@plt>
```

The first instruction loads the address of the beginning of the stack frame into rax. The second instruction moves the address of the beginning of the stack frame into rdi, which is the first argument to gets. The third instruction moves 0 into eax, which is the second argument to gets. The fourth instruction calls gets.

Effectively, this calls `gets(rbp - 0x40)`.

Time to read the man page for gets `man 3 gets`:

```
DESCRIPTION
       Never use this function.

       gets()  reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces
       with a null byte ('\0').  No check for buffer overrun is performed (see BUGS below).
```

This pretty much means that you can write as much data as you want
as long as you don't send a newline or EOF. This is a classic
stack-based buffer overflow, because you can write as much data,
going past the end of the stack frame, as you want.

We know that the stack frame is 0x40 bytes long, so we need to
write more than 0x40 bytes to overflow the buffer. We also know
that the old base pointer is 0x8 bytes long, so we need to write
0x8 more bytes. If we write more than 0x48 bytes, we will start
overwriting the return address.

So we can write a payload that transforms the stack into this:

```
[ 0x40 bytes of AAAAAAAAAAA ][ 0x8 bytes AAAAAAAA ][ overwritten return address ]
```

Now what is a useful return address? Well, we want to jump to
the function `shell`, because as the function name implies, it
calls a shell via execve. The address of the shell function is
0x401136.

So now we can create a payload for the exploit, as shown in `ntr.py`.
