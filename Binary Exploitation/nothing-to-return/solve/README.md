# Nothing to Return

This is an introductory challenge to Return Oriented Programming (ROP).

For basic-overflow and patched-shell, you had to overwrite the return address to point to the address of the `shell` function, which spawns a shell for you.

For baby-shellcode, you had to write a shellcode that spawns a shell. This implies that
the program can execute arbitrary code that you pass to it.

In this challenge, we cannot really execute instructions that are placed in the user-controlled buffer. This is because the NX (No eXecute) bit is set on the stack, which means that we cannot execute code that is placed on the stack. Also, there is no function in the program that spawns a shell for us.

So how do we get a shell? We can use ROP to get a shell.

Return Oriented Programming is a technique where you use small bits of existing code in a
program, a.k.a. gadgets, to achieve your goal.
It is usually done using the last few instructions of a function that lead
to a `ret` instruction. This is because the `ret` instruction allows us to load another address
for another gadget to return to.

The most common way to utilize ROP is by way of ret2libc. This is where you use gadgets in
the libc binary to run your intended code. In the case of a shell, the `system` function
is usually used, as it only requires one argument, which is the address of the string
containing the command to be executed.

The libc binary usually contains at least one occurence of the string `/bin/sh`.

It is important note that for the given function `system`, the first argument to a function is passed in the `rdi` register. This means that rdi should have the address of the string containing the command to be executed. You can load the address of the string into rdi by using the gadget `pop rdi; ret`.

As pointed out in patched-shell, `system` requires the stack to be aligned to 16 bytes.
To align the stack to 16 bytes, just use a `ret` gadget, which lowers the stack by 8 bytes,
and is effectively a nop.

Lastly, you are given the loaded address of `printf` by the binary. This is what is considered
a libc leak. This is useful because it allows you to calculate the address of all the gadgets
that you might get from libc. Don't use the offsets given to you by `readelf` or `objdump`,
as address space layout randomization (ASLR) rebases libc every time it is run.

In exploiting the program, you should get a stack that looks like this:

```
[ 0x48 bytes padding ]
[ address of pop rdi; ret gadget ]
[ address of /bin/sh ]
[ address of ret gadget ]
[ address of system ]
```
